1 h2 db 생성 및 프로퍼티 작성
# 프로퍼티는 yml로

2 도메인 생성(연습)
#멤버
#멤버리포지토리
- 커맨드와 쿼리를 분리할것 : 커맨드에선 리턴값을 되도록 만들지 않음(사이드 이펙트 고려)
#테스트
- @Transactional이 테스트에 있으면 테스트 직후 db를 롤백(@Rollback false로 off)
- p6soy를 사용해서 로그 콘솔 출력 가능(단, 배포시에는 성능테스트)

3 설계
#테이블 설계
-양방향 관계는 FK가 있는 테이블을 main으로 두는게 좋음
-클래스명과 테이블명을 다르게할땐 @Table
#테이블 매핑 : 변수와 테이블 column을 매핑
- PK-FK 1 @ManytoOne 2 연관관걔의 주인(반대를 mappedBy로 read only) 3 @JoinColumn으로 FK 매칭
- 일대다(한쪽이 리스트를 가지고 보통 리스트를 가진쪽이 1, read only)
* @OnetoMany가 붙으면 일반적으로 1 mappedby 2 List
* @ManytoOne이 붙으면 일반적으로 IR 주인 : JoinColumn(PK), 상대방 객체 그대로
- 다대다(JoinTable로 중간에 테이블 매개로 다:1 1:다로 분리) (본문 참조) : 실무에선 지양(수정일 추가가 힘듬)
- 일대일 : @Onetoone은 FK를 액세스가 많은 클래스에 두는게 유리

- 한 엔티티 내 부모 자식칼럼은 두 엔티티간 매핑하듯 하면됨(본문 참조)
- fetchType :
- @Embedded : 내장타입 / @Enumerated(ordinal타입은 숫자기에 항목 추가시 오류)
#상속 매핑
- @Inheritance의 strategy : 1 single 2 per(자식테이블 각각생성) 3 joined(정규화)
- single table의 경우 discriminator dtype처럼 자식을 구분
- discriminatorValue로 dype구분(default로 클래스명 사용)
- 값타입은 상속이 되지않게 기본생성자에 protect(Q참고)

4. 설계시 주의점
#엔티티에는 Stter금지
#연관관계는 모두 lazy로
- n+1 등 관련 쿼리를 늘려 성능 이슈가 발생하기때문에 Eager는 금지
(jpql의 select를 fetch고려 안하고 sql로 1:1매칭해서 n+1문제 발생)
- XtoOne같은 주인은 default가 fetch EAGER이므로 LAZY처리 해줘야함
- 관련 데이터를 불러오기 위해 fetch join이나 엔티티 그래프를 사용하면됨
#컬렉션은 필드 초기화 사용(변경x)
- 영속화시 hibernate가 컬렉션을 변환해 관리(생성자 초기화시 기존 멤버가 null문제에 자유롭지 않을 수 있음)
#테이블명
- 스프링부트 기본은 카멜 > 소문자_ , 설정 변경으로 전략 수정 가능
#cascade
- 하위객체를 영속화한 뒤 상위객체를 영속화해야하는데 cascade시 하위객체 영속화 코드를 생략가능(삭제시도 적용)
- IR된 엔티티끼리 수정을 전파
#IR 편의 메소드
- JPA입장에선 코딩이 끝나면 매핑이 완료되지만 객체간의 관계는 아직 안 맺어짐
- 양방향 관계 중 코드에서 생략될 수 있는 메서드를 미리 작성
* 테이블설계 > 엔티티 필드작성 > 객체와 테이블 매핑 - IR 설정(주인, cascade, lazy) > 객체간 IR 설정(연관관계 메소드)

5. 멤버 요소 개발
#도메인
#리포지토리
- @persistenceContext로 엔티티매니저를 주입할 수 있지만 자바 업데이트 후 다른 주입과 동일하게 처리
- createQuery는 jpql로 날라감
#서비스
- 서비스는 반드시 트랜잭션 안에서 움직여야하고 전체 < 선택 이용하여 성능 개선(read only)
- 멀티 쓰레드에서의 최후방편으로 테이블의 회원명은 unique 제약 조건 추가해야함
#테스트
- persist해도 commit을 안해서 db에 insert문이 안나감
- 테스트는 트랜잭션 이후 commit 대신 무조건 롤백이 default(설정으로 변경 가능) 또는 em.flush로 강제 db 쿼리 가능(이땐 롤백)
- 테스트 프로퍼티에서 db url을 메모리로 바꾸면 db없이 테스트 가능 > 스프링부트에선 지정 안하면 디폴트가 메모리

6. 상품 개발
#도메인
- 기존:서비스에 비즈니스로직(상품수 계산)>엔티티에 set 개선:엔티티에 바로 비즈니스로직(좀 더 객체지향스러움)
#리포지토리
- 영속화시 자동 id부여가 되는데 멤버repo는 수정할 일이 없지만 상품repo는 수정이 이뤄질일이 있으면 영속화 전 id여부 체크
#서비스
- 서비스는 언제나 기능 위임을하는 중간자이므로 개발할때 로직 생각

7. 상품 관련 개발
#도메인에 생성메소드, 비즈니스 로직, 조회 및 계산 메소드 추가
- 엔티티에 생성메소드를 추가하여 코드 가독성을 높임(아직 dto등이 추가가 안되서 쉬움)
- 생성메서드 사용시 협업을 위해 기본 생성자를 protected로 금지(jpa는 protected까지 허용), NoArguCons의 acess=protect하면 동일
#리포지토리
#서비스
- 서비스 개발에서 save할때 cascade옵션 덕분에 item,delivery 리포지토리 없이도 함께 영속화
- 라이프사이클이 동일(단방향 참조, private)할 경우 cascade 가능
- 예제 단순화를 위해 주문품목은 하나로 고정
- 트랜잭션 스크립트 패턴 : 생성할때처럼 'DI받아서 도메인,리포 값을 find 후 바꾸고 db에 쿼리 날리고...', 엔티티는 간단하고 서비스에 비즈니스로직
- 도메인 모델 패턴 : 도메인에 생성메소드(비즈니스로직)를 작성하여 서비스단의 코딩을 미리 엔티티에서 해결, 서비스는 위임만
#테스트
- 지금껏 한 테스트는 jpa와 엮어서 하는 테스트이고 좋은 테스트는 스프링 없는 단위테스트임
- 테스트는 오류가 날 수 있는 모든 부분을 체크해야함
- 서비스 테스트시 멤버와 아이템은 대상이 아니므로 em을 통해 관리하고 서비스,리포지의 경우 직접 주입받아 사용
- 도메인 모델 패턴의 경우 엔티티에 비즈니스 로직이 있어 테스트할 경우 db 등 요소와 관계없이 로직 자체만 검증 가능
#검색기능
- jpql 직접 작성은 코드도 길고 버그도 생기기 쉽고 유지보수가 너무 어려움
- criteria라는 jpa 동적쿼리 표준(자바코드를 jpql로 변환)이 있지만 코드가독성이 실무에 맞지않음(어떤 쿼리가 생성되는지 예상이 안됨)
- 이를 보완한 것이 querydsl
8. 화면 구현
- home은 @requestMapping
- 회원가입에서는 폼 사용을 위해 Model 객체를 인자로 받고 attribute로 속성을 담아서 뷰로 전달(뷰에서 객체(폼)에 등록된 이름으로 접근 가능)
- Post를 줄때는 인자로 form을 넘김 > 멤버를 만들어서 서비스로 넘겨줌
- BindingResult 인자로 에러 처리 가능, 리턴을 페이지로 돌려줘도 라이브러리가 폼 자체에서 로직
- 타임리프에서 ?는 null시 더이상 로직 x
- 폼을 엔티티에서 처리하냐 폼 객체를 만드냐의 문제는 어플리케이션 크기에 따라 다르지만 폼은 폼객체나 dto를 사용하는걸 권장
(수정하는 경우 엔티티를 손대기때문에 dto로 뷰를 접근하는게 나음, api를 만드는 경우는 절대 엔티티를 건들면 안됨)
- 폼을 인자로 전달할때 @modelattribute로 괄호 내에서 지정
- @modelattribute는 1 빈 객체를 생성 2 생성된 객체에 http로 들어오는 값들을 자동 바인딩 3 이를 model객체에 전달
(model.addAttribue와의 차이는 @는 자바빈, 뷰와 필드가 일치할 경우만 가능하고 실행 단위가 컨트롤러/메서드로 다름)
- @Pathvariable로 url과 인자 매핑

# ** 준영속 엔티티
- 상품 수정의 new book은 이미 id가 db에 생성되어 jpa가 더 이상 관리하지 않는 준영속 엔티티
- 준영속 엔티티는 직접 개발자가 service에 저장하지 않으면 다른 메소드로는 db에 반영되지 않음 > 이 때, merge와 dirty checking
* dirty checking
- 영속성 컨텍스트에서 엔티티(영속 상태)를 다시 조회한 후 데이터를 수정
- 서비스에 트랜잭션 안에서 데이터 변경이 감지되면 flush가 날라가고(변경 내역 탐지) commit됨
- 이때, 데이터값만 변경하고 저장 등 메소드가 없어도 findId로 찾은 객체는 영속 상태이기때문에 jpa가 데이터를 변경
* merge
- 준영속 상태를 영속으로 변경하는 기능
- 기존 영속 데이터를 조회 후 수정하여 다시 저장(이미 영속화된 객체 내용만 수정되고 수정 내용이 담긴 최신 객체는 영속화되지 않음)
- 변경 감지와 로직은 비슷 but dirty checking은 속성 선택이 가능하지만 merge는 모든 속성이 변경됨(병합시 값이 없으면 null이 저장됨)
(개발자가 값의 유지를 의도했으나 값이 null로 변경되는 문제가 critical함)
- 그래서 서비스단에 Set을 까는거보단 리포지토리에서 세팅메소드를 만들어서 서비스가 호출하는 것이 훨씬 좋음
- 또한 컨트롤러에서 엔티티를 생성하지 말 것
- 컨트롤러에 param이 너무 많아지면 서비스단에서 dto를 만들어서 넘김

8. 주문 개발
#주문 컨트롤러
- 컨트롤러는 서비스에 작업을 위임(컨트롤러에서 엔티티를 만지면 영속상태가 풀리므로 트랜잭션 내에서 서비스가 엔티티를 관리하게끔 함)